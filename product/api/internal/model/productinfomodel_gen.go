// Code generated by goctl. DO NOT EDIT.
// versions:
//  goctl version: 1.9.2

package model

import (
	"WMSS/product/api/internal/types"
	"context"
	"database/sql"
	"fmt"
	"strings"

	"github.com/zeromicro/go-zero/core/stores/builder"
	"github.com/zeromicro/go-zero/core/stores/sqlx"
	"github.com/zeromicro/go-zero/core/stringx"
)

var (
	productInfoFieldNames          = builder.RawFieldNames(&ProductInfo{})
	productInfoRows                = strings.Join(productInfoFieldNames, ",")
	productInfoRowsExpectAutoSet   = strings.Join(stringx.Remove(productInfoFieldNames, "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), ",")
	productInfoRowsWithPlaceHolder = strings.Join(stringx.Remove(productInfoFieldNames, "`product_id`", "`create_at`", "`create_time`", "`created_at`", "`update_at`", "`update_time`", "`updated_at`"), "=?,") + "=?"
)


// 定义字段列表常量
const (
	productRows = "`product_id`, `product_name`, `product_type`, `product_sub_type`, `risk_level`, `product_status`, `manager`, `custodian`, `purchase_fee_rate`, `redemption_fee_rule`, `description`, `create_time`, `update_time`, `deleted_at`, `create_by`"
)

type (
	productInfoModel interface {
		Insert(ctx context.Context, data *ProductInfo) (sql.Result, error)
		FindOne(ctx context.Context, productId string) (*ProductInfo, error)
		FindOneByProductName(ctx context.Context, productName string) (*ProductInfo, error)
		Update(ctx context.Context, data *ProductInfo) error
		Delete(ctx context.Context, productId string) error
		DeleteLogical(ctx context.Context, productId string) error  // 逻辑删除
		FindList(ctx context.Context, query *types.ProductListReq) ([]*ProductInfo, int64, error)
	}



	defaultProductInfoModel struct {
		conn  sqlx.SqlConn
		table string
	}

	ProductInfo struct {
		ProductId         string          `db:"product_id"`
		ProductName       string          `db:"product_name"`
		ProductType       string          `db:"product_type"`
		ProductSubType    sql.NullString  `db:"product_sub_type"`
		RiskLevel         string          `db:"risk_level"`
		ProductStatus     string          `db:"product_status"`
		Manager           string          `db:"manager"`
		Custodian         string          `db:"custodian"`
		PurchaseFeeRate   sql.NullFloat64 `db:"purchase_fee_rate"`
		RedemptionFeeRule sql.NullString  `db:"redemption_fee_rule"`
		Description       sql.NullString  `db:"description"`
		CreateTime        sql.NullTime    `db:"create_time"`
		UpdateTime        sql.NullTime    `db:"update_time"`
		DeletedAt         sql.NullTime    `db:"deleted_at"`
		CreateBy          uint64          `db:"create_by"`
	}
)

func newProductInfoModel(conn sqlx.SqlConn) *defaultProductInfoModel {
	return &defaultProductInfoModel{
		conn:  conn,
		table: "`product_info`",
	}
}

func (m *defaultProductInfoModel) Delete(ctx context.Context, productId string) error {
	query := fmt.Sprintf("delete from %s where `product_id` = ?", m.table)
	_, err := m.conn.ExecCtx(ctx, query, productId)
	return err
}

func (m *defaultProductInfoModel) FindOne(ctx context.Context, productId string) (*ProductInfo, error) {
	query := fmt.Sprintf("select %s from %s where `product_id` = ? limit 1", productInfoRows, m.table)
	var resp ProductInfo
	err := m.conn.QueryRowCtx(ctx, &resp, query, productId)
	switch err {
	case nil:
		return &resp, nil
	case sqlx.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

// Delete 逻辑删除产品
func (m *defaultProductInfoModel) DeleteLogical(ctx context.Context, productId string) error {
	query := fmt.Sprintf(
		"UPDATE %s SET `deleted_at` = NOW() WHERE `product_id` = ? AND `deleted_at` IS NULL",
		m.table,
	)

	result, err := m.conn.ExecCtx(ctx, query, productId)
	if err != nil {
		return err
	}

	// 检查是否有行被更新
	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return err
	}

	// 如果没有行被更新，说明产品不存在或已经被删除
	if rowsAffected == 0 {
		return ErrNotFound
	}

	return nil
}

func (m *defaultProductInfoModel) FindOneByProductName(ctx context.Context, productName string) (*ProductInfo, error) {
	var resp ProductInfo
	query := fmt.Sprintf("select %s from %s where `product_name` = ? limit 1", productInfoRows, m.table)
	err := m.conn.QueryRowCtx(ctx, &resp, query, productName)
	switch err {
	case nil:
		return &resp, nil
	case sqlx.ErrNotFound:
		return nil, ErrNotFound
	default:
		return nil, err
	}
}

func (m *defaultProductInfoModel) Insert(ctx context.Context, data *ProductInfo) (sql.Result, error) {
	query := fmt.Sprintf("insert into %s (%s) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", m.table, productInfoRowsExpectAutoSet)
	ret, err := m.conn.ExecCtx(ctx, query, data.ProductId, data.ProductName, data.ProductType, data.ProductSubType, data.RiskLevel, data.ProductStatus, data.Manager, data.Custodian, data.PurchaseFeeRate, data.RedemptionFeeRule, data.Description, data.DeletedAt, data.CreateBy)
	return ret, err
}

func (m *defaultProductInfoModel) Update(ctx context.Context, newData *ProductInfo) error {
	query := fmt.Sprintf("update %s set %s where `product_id` = ?", m.table, productInfoRowsWithPlaceHolder)
	_, err := m.conn.ExecCtx(ctx, query, newData.ProductName, newData.ProductType, newData.ProductSubType, newData.RiskLevel, newData.ProductStatus, newData.Manager, newData.Custodian, newData.PurchaseFeeRate, newData.RedemptionFeeRule, newData.Description, newData.DeletedAt, newData.CreateBy, newData.ProductId)
	return err
}

func (m *defaultProductInfoModel) FindList(ctx context.Context, query *types.ProductListReq) ([]*ProductInfo, int64, error) {
	// 1. 构建查询条件
	var conditions []string
	var args []interface{}

	if query.SearchKeyWords != "" {
		conditions = append(conditions, "product_name LIKE ?")
		args = append(args, "%"+query.SearchKeyWords+"%")
	}

	if query.ProductType != "" {
		conditions = append(conditions, "product_type = ?")
		args = append(args, query.ProductType)
	}

	if query.ProductSubType != "" {
		conditions = append(conditions, "product_sub_type = ?")
		args = append(args, query.ProductSubType)
	}

	if query.RiskLevel != "" {
		conditions = append(conditions, "risk_level = ?")
		args = append(args, query.RiskLevel)
	}

	if query.ProductStatus != "" {
		conditions = append(conditions, "product_status = ?")
		args = append(args, query.ProductStatus)
	}

	if query.Manager != "" {
		conditions = append(conditions, "manager LIKE ?")
		args = append(args, "%"+query.Manager+"%")
	}

	if query.Custodian != "" {
		conditions = append(conditions, "custodian LIKE ?")
		args = append(args, "%"+query.Custodian+"%")
	}

	// 逻辑删除过滤
	conditions = append(conditions, "deleted_at IS NULL")

	whereClause := ""
	if len(conditions) > 0 {
		whereClause = "WHERE " + strings.Join(conditions, " AND ")
	}

	// 2. 查询总数
	countSQL := fmt.Sprintf("SELECT COUNT(*) FROM %s %s", m.table, whereClause)
	var total int64
	err := m.conn.QueryRowCtx(ctx, &total, countSQL, args...)
	if err != nil {
		return nil, 0, err
	}

	if total == 0 {
		return []*ProductInfo{}, 0, nil
	}

	// 3. 分页查询
	offset := (query.Page - 1) * query.PageSize
	listSQL := fmt.Sprintf(`
        SELECT %s FROM %s %s 
        ORDER BY create_time DESC 
        LIMIT ? OFFSET ?
    `, productRows, m.table, whereClause)

	args = append(args, query.PageSize, offset)

	var products []*ProductInfo
	err = m.conn.QueryRowsCtx(ctx, &products, listSQL, args...)
	if err != nil {
		return nil, 0, err
	}

	return products, total, nil
}

func (m *defaultProductInfoModel) tableName() string {
	return m.table
}
